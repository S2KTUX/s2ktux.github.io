<div class="lesson-wrapper">

    <header class="lesson-header">
        <span class="badge">RHCSA Objetivo</span>
        <h1>Administrar la seguridad</h1>
        <p>Firewall, permisos, autenticaci√≥n SSH y hardening con SELinux</p>

        <a href="https://youtu.be/mDqQq9ZGehA" target="_blank" class="video-card">
            <div class="video-icon">üé¨</div>
            <div class="video-text">
                <strong>VER VIDEO YOUTUBE - CLASE 10</strong>
                <span>Firewall, SSH y seguridad avanzada con SELinux</span>
            </div>
        </a>
    </header>

    <div class="lesson-layout">

        <aside class="lesson-toc">
            <h4>Objetivos del bloque</h4>
            <ul>
                <li><a href="#obj1">1. Firewall</a></li>
                <li><a href="#obj2">2. Permisos (umask)</a></li>
                <li><a href="#obj3">3. Claves SSH</a></li>
                <li><a href="#obj4">4. Modos SELinux</a></li>
                <li><a href="#obj5">5. Contextos SELinux</a></li>
                <li><a href="#obj6">6. Restaurar contextos</a></li>
                <li><a href="#obj7">7. Puertos SELinux</a></li>
                <li><a href="#obj8">8. Booleanos SELinux</a></li>
            </ul>
        </aside>

        <div class="course-content">

            <section id="obj1" class="lesson-section">
                <h3>1. Configurar el firewall con firewalld</h3>
                <p>Como ya sabemos, firewalld permite gestionar reglas din√°micas mediante zonas, servicios y reglas avanzadas almacenadas en <code>/etc/firewalld/zones/</code>.</p>
                <p>Podemos crear aplicaciones personalizadas copiando servicios desde <code>/usr/lib/firewalld/services/</code> hacia <code>/etc/firewalld/services/</code> y aplicando contextos SELinux con <code>restorecon</code>.</p> 
                <img src="/images/firewall-app.png" alt="app perso de firewall">
                <p>Las <strong>rich rules</strong> permiten crear reglas espec√≠ficas por IP, puerto o servicio.</p>
                <img src="/images/firewall-rich.png" alt="richrules de firewall">
                <p>NAT permite enrutar tr√°fico mediante:</p>
                <ul>
                    <li><strong>Masquerade</strong> ‚Üí acceso a internet desde redes internas.</li>
                    <li><strong>Port Forwarding</strong> ‚Üí redirecci√≥n de puertos.</li>
                    <li><strong>Rich Rule NAT</strong> ‚Üí redirecci√≥n espec√≠fica por IP/red.</li>
                </ul>
                <img src="/images/firewall-nat.png" alt="nat de firewall">
                <p>Las <code>ipset</code> permiten manejar listas grandes de IPs de forma eficiente.</p>
                <img src="/images/firewall-ipset.png" alt="ipset de firewall">
            </section>

            <section id="obj2" class="lesson-section">
                <h3>2. Administrar permisos predeterminados (umask)</h3>
                <p><code>umask</code> define los permisos que se eliminan al crear archivos o directorios.</p>
                <p>El valor m√°ximo es 666 para archivos y 777 para directorios (ya que x no se aplica por seguridad).Es decir, la regla o la suma es  Permisos totales - UMASK = Permisos reales. Si el umask es 022, el archivo se crea con 644 (666-022) y el directorio con 755 (777-022).</p>
                <p>Puede aplicarse temporalmente con <code>umask</code> o permanentemente en <code>/etc/profile</code> para global o <code>~/.bashrc</code> para un usuario en especifico.</p>
            </section>
            </section>

            <section id="obj3" class="lesson-section">
                <h3>3. Autenticaci√≥n SSH mediante claves</h3>
                <p>Permite acceso seguro sin contrase√±a usando criptograf√≠a p√∫blica/privada. La clave p√∫blica se copia al servidor y la privada nunca se comparte.</p>
                <p>Lo que tenemos que tener m√°s claro es que la clave publica es la que compartiremos con el servidor pero la privada NUNCA la compartiremos. Practicad el hecho de que <code>ssh-copy-id</code> podr√≠a fallar, el examen est√° hecho para ponernos trampas en todo momento</p>
                <img src="/images/ssh-key.png" alt="Autenticaci√≥n SSH">
                <p>Debemos verificar en <code>/etc/ssh/sshd_config</code> que est√©n activadas las opciones:</p>
                <ul>
                    <li><code>PubkeyAuthentication yes</code></li>
                    <li><code>AuthorizedKeysFile .ssh/authorized_keys</code></li>
                </ul>

                <p>Tras cambios reiniciamos el servicio con <code>systemctl restart sshd</code>.</p>
            </section>

            <section id="obj4" class="lesson-section">
                <h3>4. Modos de SELinux</h3>
                <p>SELinux puede funcionar en tres estados:</p>
                <ul>
                    <li><strong>Enforcing</strong> ‚Üí bloquea accesos no permitidos.</li>
                    <li><strong>Permissive</strong> ‚Üí solo registra eventos.</li>
                    <li><strong>Disabled</strong> ‚Üí desactivado.</li>
                </ul>
                <p>Se consulta con <code>getenforce</code> y se cambia temporalmente con <code>setenforce</code>. Para hacerlo permanente se modifica <code>/etc/selinux/config</code>.</p>
                <img src="/images/selinux-modes.png" alt="Modos SELinux">
            </section>

            <section id="obj5" class="lesson-section">
                <h3>5. Contextos SELinux</h3>
               <p>SELinux etiqueta recursos con un contexto (usuario:rol:tipo:nivel). El campo m√°s importante es el <strong>tipo</strong>.</p>
                <ul>
                    <li><code>ls -Z</code> ‚Üí contexto de archivos.</li>
                    <li><code>ps -eZ</code> ‚Üí contexto de procesos.</li>
                </ul>
                <p>No hay que memorizarlos los contextos.<code>semanage fcontext -l | grep servicio</code> lista las etiquetas recomendadas, <code>matchpathcon /ruta/archivo</code> indica la que deber√≠a tener y <code>ls -Z</code> la que tiene realmente.</p>
                <img src="/images/selinux-context.png" alt="Contextos SELinux">
                <p>Para investigar fallos de SELinux, usa <code>ausearch</code> (rastreador) y <code>audit2why</code> (traductor). Lo m√°s com√∫n es combinarlos con <code>ausearch -m avc -ts recent | audit2why</code>, ya que la mayor√≠a de bloqueos se registran bajo el tipo avc.</p>
                <img src="/images/selinux-audit.png" alt="AUSEARCH -AUDIT- SELinux" >
            </section>

            <section id="obj6" class="lesson-section">
                <h3>6. Restaurar contextos predeterminados</h3>
                <p><code>restorecon</code> restaura etiquetas correctas cuando archivos se mueven o cambian manualmente.</p>
                <p>El ejemplo m√°s sencillo es el servicio httpd. Este servicio se encuentra en <code>/var/www/html/</code> y necesita un contexto para funcionar. Si importamos un archivo desde otra ubicaci√≥n y no nos aseguramos de que tenga un contexto correcto, no funcionar√°. Tal y como hemos visto en la imagen de <code>ausearch -m avc -ts recent | audit2why</code></p>
                <img src="/images/restorecon.png" alt="Uso de restorecon">
                <p>Para nuevas rutas usamos <code>semanage fcontext -a</code> y aplicamos cambios con <code>restorecon -Rv</code>.</p>
                <img src="/images/restorecon-add.png" alt="Uso de restorecon">
                <p> De la misma manera que agregamos con <code>-a</code>, podemos eliminar una regla que hayamos creado exactamente igual pero con <code>-d</code> o modificarla con <code>-m</code>. Recordad lanzar siempre el comando <code>restorecon -Rv</code> para aplicar esos cambios. En el video menciono <code>chcon</code> pero este har√≠a un cambio temporal y se perder√≠a al reiniciar, por lo que mejor usar semanage fcontext. </p>
                
            </section>

            <section id="obj7">
                <h3>Administrar etiquetas de puerto SELinux</h3>
                <p>Si un servicio (ej. Apache) debe escuchar en un puerto no est√°ndar, debemos etiquetar ese puerto en SELinux. Podemos comprobar el contexto de los puertos de la misma manera que la de los servicios : <code>semanage port -l | grep servicio</code>.</p>
                <img src="/images/semanage-ports.png" alt="Puertos SELinux">
                <p>Si un servicio necesita usar un puerto diferente, debemos a√±adirlo con <code>semanage port -a X -p tcp PUERTO</code>. Por ejemplo, permitir que <strong>httpd</strong> use el puerto 8080:</p>
                <img src="/images/semanage-ports2.png" alt="Puertos SELinux change">
                <p>Si el puerto ya existe y queremos modificarlo usamos <code>-m</code>, y para eliminarlo usamos <code>-d</code>.</p>
            </section>
             <section id="obj8" class="lesson-section">
                <h3>8. Booleanos SELinux</h3>
                <p>Los booleanos son interruptores (on/off) que permiten cambiar reglas de SELinux en tiempo real sin modificar la pol√≠tica completa. Tenemos que tener en cuenta que si un servicio funciona pero SELinux lo bloquea lo primero que revisaremos ser√° los booleanos</p>
                <p> Con el comando <code>getsebool -a</code> podemos listar todos los booleanos disponibles y podemos filtrar con grep servicio. Tambien podemos filtrar con <code>semanage boolean -l | grep X</code>. </p>
                <img src="/images/selinux-booleans.png" alt="Booleanos SELinux">
                <p>Se listan con <code>getsebool -a</code> y se modifican con <code>setsebool</code>. Para hacerlo persistente usamos <code>-P</code>.</p>
                <img src="/images/selinux-booleans2.png" alt="Booleanos SELinux">
                <p>No es necesario memorizar booleanos concretos, sino saber identificarlos con <code>getsebool</code> o <code>getsebool -a</code> y activarlos correctamente usando <code>setsebool</code> o <code>setsebool -P</code> cuando SELinux bloquea un servicio.</p
                <p>Ejemplos comunes:</p>
                <ul>
                    <li><code>httpd_can_network_connect</code></li>
                    <li><code>httpd_enable_homedirs</code></li>
                    <li><code>ftp_home_dir</code></li>
                    <li><code>ssh_sysadm_login</code></li>
                    <li><code>container_manage_cgroup</code></li>
                </ul>       
            </section>

        </div>
    </div>
</div>
