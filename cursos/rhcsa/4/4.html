<div class="lesson-wrapper">
    <header class="lesson-header">
        <span class="badge">RHCSA Objetivo 4</span>
        <h1>Operar sistemas en funcionamiento</h1>
        <p>GestiÃ³n de arranque, procesos, servicios y diagnÃ³stico del sistema</p>
        
        <a href="https://youtu.be/TyjaQtZcA9Y" target="_blank" class="video-card">
            <div class="video-icon">ðŸŽ¬</div>
            <div class="video-text">
                <strong>VER VIDEO YOUTUBE - CLASE 4</strong>
                <span>AdministraciÃ³n de sistemas y resoluciÃ³n de problemas</span>
            </div>
        </a>
    </header>

    <div class="lesson-layout">
        <aside class="lesson-toc">
            <h4>Objetivos del bloque</h4>
            <ul>
                <li><a href="#obj1">1. Arranque y parada</a></li>
                <li><a href="#obj2">2. Targets de Systemd</a></li>
                <li><a href="#obj3">3. Interrumpir el arranque (Root)</a></li>
                <li><a href="#obj4">4. GestiÃ³n de procesos</a></li>
                <li><a href="#obj5">5. Prioridades (Nice/RT)</a></li>
                <li><a href="#obj6">6. Tuning Profiles</a></li>
                <li><a href="#obj7">7. InterpretaciÃ³n de logs</a></li>
                <li><a href="#obj8">8. Persistencia de Journal</a></li>
                <li><a href="#obj9">9. Servicios de Red</a></li>
                <li><a href="#obj10">10. Transferencia segura</a></li>
            </ul>
        </aside>

<div class="course-content">

            <section id="obj1" class="lesson-section">
                <h3>1. Arrancar, reiniciar y apagar sistemas</h3>
                <p>El proceso inicial del sistema es PID 1, actualmente gestionado por systemd, sucesor del antiguo init, encargado de gestionar el arranque y los servicios. Los <strong>runlevels ( init 0-6)</strong> fueron sustituidos por <strong>targets</strong>  que cumplen la misma funciÃ³n.</p>

                <ul>
                    <li><strong>0 â†’ poweroff.target</strong> â€” Apagar el sistema</li>
                    <li><strong>1 â†’ rescue.target</strong> â€” Modo rescate (usuario Ãºnico)</li>
                    <li><strong>3 â†’ multi-user.target</strong> â€” Multiusuario en modo texto</li>
                    <li><strong>5 â†’ graphical.target</strong> â€” Entorno grÃ¡fico</li>
                    <li><strong>6 â†’ reboot.target</strong> â€” Reiniciar el sistema</li>
                    <li><strong>emergency.target</strong> â€” Modo emergencia mÃ­nimo</li>
               </ul>
                <p> Podemos apagar o reiniciar el sistema usando :</p>
                <ul>
                    <li><strong>systemctl poweroff</strong> â†’ Apaga el sistema</li>
                    <li><strong>systemctl reboot</strong> â†’ Reinicia el sistema</li>
                    <li><strong>shutdown -h now</strong> â†’ Apaga el sistema inmediatamente</li>
                    <li><strong>shutdown -r +5</strong> â†’ Reinicia el sistema en 5 minutos</li>
                </ul>
            </section>

            <section id="obj2" class="lesson-section">
                <h3>2. Arrancar sistemas en diferentes objetivos manualmente</h3>
                <p> En <strong>systemd</strong>, los <strong>targets</strong> definen el estado operativo del sistema. Podemos cambiar el target de forma <strong>temporal</strong> o <strong>permanente</strong>.
                </p>
                <p><strong>Cambio temporal:</strong></p>
                <ul>
                    <li><code>systemctl isolate TARGET</code> â†’ Cambia el target en la sesiÃ³n actual</li>
                    <li>Desde GRUB, editando la lÃ­nea de arranque y aÃ±adiendo: <code>systemd.unit=TARGET</code></li>
                </ul>
                <p><strong>Cambio permanente:</strong></p>
                <ul>
                    <li><code>systemctl set-default TARGET</code> â†’ Define el target por defecto</li>
                    <li><code>systemctl get-default</code> â†’ Muestra el target actual</li>
                </ul>
                <img src="/images/per-target.png" alt="Ejemplo cambio de target permanente" loading="lazy" >
            </section>


            <section id="obj3" class="lesson-section">
                <h3>3. Interrumpir el arranque para obtener acceso</h3>
                <p>Durante el arranque, es posible interrumpir GRUB para acceder y modificar parametros Esto lo podemos hacer ya sea para encender el sistema con un target especifico, recuperar la contraseÃ±a o entrar como modo emergencia para revisar posibles errores </p>
                <p>Uno de los puntos mas importantes del examen es resetear la contraseÃ±a de root para poder realizar el examen. Para ello lo primero que haremos serÃ¡ entrar en GRUB y editar la entrada presionando <strong>e</strong>.</p>
                <p>Una vez dentro, modificamos la linea de linux, aÃ±adiendo al final <strong>rd.break</strong> (si no funciona podriamos poner como alternativa init=/bin/bash) y arrancaremos con Ctrl + X.</p>
                <img src="/images/root-rec1.png" alt="grub line" loading="lazy">  
                
                <p> Una vez arrancado, tendremos que seguir los siguientes pasos :</p>
                <img src="/images/root-rec2.png" alt="grub line" loading="lazy">
            </section>

            <section id="obj4" class="lesson-section">
                <h3>4. Identificar y eliminar procesos</h3>
                <p>Linux ofrece varias herramientas para ver quÃ© procesos estÃ¡n usando mÃ¡s recursos. Podemos hacerlo de forma <strong>estÃ¡tica</strong> con <code>ps</code> o de forma <strong>interactiva</strong> con <code>top</code>.</p>
                <p>El comando <code>top</code> muestra los procesos en tiempo real y permite ver el consumo de CPU y memoria. Desde <code>top</code> tambiÃ©n podemos matar procesos pulsando <strong>k</strong></p>
                <img src="/images/top.png" alt="top line" loading="lazy">
                <p>Los flags mÃ¡s importantes de ps serÃ­an :</p>
                <ul>
                    <li><strong>ps aux</strong> â†’ Muestra todos los procesos del sistema</li>
                    <li><strong>ps -ef</strong> â†’ Vista completa de los procesos en formato extendido</li>
                </ul>
                <img src="/images/ps.png" alt="ps" loading="lazy">
                <p> Para comprobar el uso de memoria del sistema utilizamos el comando <code>free -h</code>, que muestra la memoria total, usada y libre de forma legible.</p> 
                <img src="/images/free.png" alt="free pic" loading="lazy">
                <p>Para finalizar procesos utilizamos el comando <code>kill</code> que tiene diferentes flags : </p>
                <ul>
                    <li><strong>kill -15 PID</strong> : Es la que se usa por defecto, para el proceso</li>
                    <li><strong>kill -9 PID</strong> : La mÃ¡s agrevisa, fuerza la finalizaciÃ³n del proceso</li>
                    <li><strong>pkill nombre</strong> : para todos los procesos relacionados con ese nombre</li>
                </ul>
            </section>

            <section id="obj5" class="lesson-section">
                <h3>5. Ajustar la programaciÃ³n de procesos (Nice/RT)</h3>
                <p>La prioridad de ejecuciÃ³n se controla con <strong>nice</strong> y <strong>renice</strong>. Los valores van de <strong>-20</strong> (mÃ¡s prioridad) a <strong>19</strong> (menos prioridad). La podemos comprobar con top. </p>
                <ul>
                    <li><strong>nice -n 10 comando</strong> â†’ Ejecuta un comando con menor prioridad</li>
                    <li><strong>renice -5 PID</strong> â†’ Cambia la prioridad de un proceso en ejecuciÃ³n</li>
                </ul>
                <img src="/images/nice-re.png" alt="nice example" loading="lazy">
                <p> Por otro lado tenemos los procesos real time, que son procesos que tienen prioridad ante todos y va con valores de 0 a 99, siendo 99 el mas alto. Podemos ver su informaciÃ³n, cambiar su prioridad o lanzar un proceso con un rt especifico :  </p>
                <ul>
                    <li><strong>chrt -p PID</strong> â†’ Muestra la polÃ­tica y prioridad real time de un proceso</li>
                    <li><strong>chrt -r -p PRIORIDAD PID</strong> â†’ Cambia la prioridad real time de un proceso existente</li>
                    <li><strong>chrt -r PRIORIDAD comando</strong> â†’ Ejecuta un comando con prioridad real time</li>
                </ul>
                <img src="/images/chrt.png alt="grub line">
            </section>

            <section id="obj6" class="lesson-section">
                <h3>6. Administrar perfiles de sintonizaciÃ³n (Tuned)</h3>
                <p>El servicio <strong>tuned</strong> optimiza el rendimiento segÃºn el rol del servidor.</p>
                <p> Los perfiles mÃ¡s interesantes podrÃ­an ser : balanced, virtual-guest, throughput-performance, network-latency... </p>
                <p> Podemos listar los perfiles con <code>tuned-adm list</code>, ver el perfil actual con el comando <code>tuned-adm active</code>, cambiarlo con <code>tuned-adm profile nombre-perfil</code> o apagar este servicio con <code>tuned-adm off</code>.</p>
                <img src="/images/tuned.png" alt="tuned-adm ejemplo" loading="lazy">
            </section>

            <section id="obj7" class="lesson-section">
                <h3>7. Localizar e interpretar logs y journals</h3>
                <p>Los logs tradicionales se encuentran en <code>/var/log</code>. Systemd utiliza <strong>journalctl</strong> para gestionar los logs y no se pueden leer en texto plano ya que son binarios. Algunos filtros que podemos hacer son :</p>
                <ul>
                    <li><code>journalctl -p err</code> : Solo errores.</li>
                    <li><code>journalctl -u sshd</code> : Logs de un servicio especÃ­fico.</li>
                    <li><code>journalctl -xe</code> : Ayuda extendida sobre fallos recientes.</li>
                    <li><code>journalctl -f </code> : Muestra los mensajes en tiempo real</li>
                    <li><code>journalctl -b </code> : Logs del arranque del sistema</li>
                </ul>
                <img src="/images/logs-ex.png" alt="logs ejemplo" loading="lazy">
            </section>

            <section id="obj8" class="lesson-section">
                <h3>8. Preservar journals del sistema</h3>
                <p>Por defecto, los journals pueden ser volÃ¡tiles. Para que el journal no se borre al reiniciar, debemos crear la estructura manualmente</p>
                <pre><code>mkdir /var/log/journal
                    chown root:systemd-journal /var/log/journal
                    chmod 2755 /var/log/journal</code></pre>
                <p>Configurar <code>Storage=persistent</code> en <code>/etc/systemd/journald.conf</code> y reiniciar el servicio.</p>
                <img src="/images/log-pers.png" alt="logs persistent" loading="lazy">
                <img src="/images/log-pers2.png" alt="logs persistent" loading="lazy">
                <p> Preferiblemente, siempre que hagamos un cambio a un archivo de configuraciÃ³n de un servicio, reiniciaremos este servicio <code>systemctl restart systemd-journald</code>.</p>
                <p>No hemos mencionado la rotaciÃ³n de logs, para ello podemos usar</p>
                <ul>
                    <li><strong>--vacuum-time</strong> â†’ Borra logs antiguos segÃºn el tiempo indicado. </li>
                    <li><strong>--vacuum-size</strong> â†’ Borra logs hasta ocupar el tamaÃ±o indicado</li>
                    <li><strong>--rotate</strong> â†’ Fuerza la rotaciÃ³n del journal actual</li>
                    <li><strong>--disk-usage</strong> â†’ Muestra cuÃ¡nto espacio ocupan los logs</li>
                    <li><strong>--list-boots</strong> â†’ Muestra los arranques registrados en el sistema</li>
                </ul>
                <img src="/images/logs-rotated.png" alt="logs persistent conf" loading="lazy">
            </section>

            <section id="obj9" class="lesson-section">
                <h3>9. Iniciar, detener y comprobar servicios de red</h3>
                <p>Los servicios se pueden gestionar a traves de varios comandos : <code>systemctl</code>, <code>ip</code> o <code>nmcli</code>.</p>
                <p> Cuando usemos systemctl, el servicio se llama NetworkManager. Usaremos los comandos : </p>
                <ul>
                    <li><strong>systemctl start NetworkManager</strong> â†’ Levantar</li>
                    <li><strong>systemctl stop NetworkManager</strong> â†’ Parar</li>
                    <li><strong>systemctl restart NetworkManager</strong> â†’ Reiniciar</li>
                    <li><strong>systemctl status NetworkManager</strong> â†’ Comprobar el estado</li>
                </ul>
                <img src="/images/networkmanager.png" alt="nm ejemplo" >
                <p> Tambien podemos usar nmcli para gestionar los servicios de red :</p>
                <ul>
                    <li><strong>nmcli connection up "interfaz" </strong> â†’ Levantar</li>
                    <li><strong>nmcli connection down "interfaz"</strong> â†’ Parar</li>
                    <li><strong>nmcli connection show</strong> â†’ Comprobar</li>
                </ul>
                <img src="/images/nmcli-basic.png" alt="nmcli basic ejemplo" loading="lazy">
                <p> Por ultimo, podemos usar ip ( aunque este no es recomendable ya que solo hace cambios temporales ) : </p>
                <ul>
                    <li><strong>ip link set "interfaz" up</strong> â†’ Levantar</li>
                    <li><strong>ip link set "interfaz" down</strong> â†’ Parar</li>
                    <li><strong>ip a</strong> â†’ Comprobar</li>
                </ul>
                <img src="/images/ip-basic.png" alt="ip basic ejemplo" loading="lazy">
            </section>

            <section id="obj10" class="lesson-section">
                <h3>10. Transferir archivos de forma segura</h3>
                <p>La transferencia segura se realiza mediante SSH. Tenemos principalmente : scp y sftp. </p>
                <p> La sintaxis de scp puede ser :</p>
                <ul>
                    <li><strong>scp local user@ip:/remoto</strong> â†’ De local a remoto  </li>
                    <li><strong>scp user@ip:/remoto /local</strong> â†’ De remoto a local</li>
                </ul>   
                <p>Las opciones mÃ¡s usadas son : </p>
                <ul>
                    <li><strong>-r</strong> â†’  Realizar copias recursivas. </li>
                    <li><strong>-P</strong> â†’ Indicar puerto</li>
                    <li><strong>-p </strong> â†’ Conservar permisos y otros datos</li>
                </ul>
                <img src="/images/scp.png" alt="scp ejemplo" loading="lazy">
                <img src="/images/scp-remoto.png" alt="scp-remoto ejemplo" loading="lazy">
                <p> Por otro lado, tenemos <code>sftp</code> que tiene un menÃº interactivo donde podemos lanzar comandos. Para conectarnos usaremos <code>sftp user@IP</code>.</p>
                <p> Si queremos lanzar comandos en local lanzariamos los comandos con una l delante, por ejemplo lcd, lpwd...</p>
                <p> Los mÃ¡s a tener en cuenta serÃ­an : <code>put</code>( Subir un archivo) y <code>get</code>( Descargarlo)</p>
                
            </section>

        </div>
    </div>
</div>
