<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="RHCSA - Crear scripts de shell simples">
    <meta name="keywords" content="RHCSA, Linux, bash, scripts, if, for, variables">
    <meta name="author" content="SysRiser">
    <title>S2KTUX - RHCSA | Scripts de shell</title>
    <link rel="stylesheet" href="/conf/styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="/images/favicon.png">
</head>
<body>

<div class="gradient-bg"></div>

<header>
    <div class="header-left">
        <a href="/index.html" class="header-logo">S2KTUX</a>
    </div>
    <nav>
        <a href="/index.html">Inicio</a>
        <a href="/cursos/cursos.html">Cursos</a>
        <a href="/proyectos/proyectos.html">Proyectos</a>
    </nav>
</header>

<main id="contenido">

    <div class="hero">
        <h1>Crear scripts de shell simples</h1>
        <p>Automatización básica con Bash</p>
        <p><a href="https://youtu.be/CRaP1XjdS4A" target="_blank">VER VIDEO YOUTUBE - CLASE 3</a></p>
    </div>

    <a href="/cursos/cursos.html" class="back-link">← Volver al curso RHCSA</a>

    <div class="course-page">

        <div class="sidebar">
            <h3>Objetivos del bloque</h3>
            <ul>
                <li><a href="#obj1">Ejecutar código condicionalmente</a></li>
                <li><a href="#obj2">Uso de bucles para procesar datos</a></li>
                <li><a href="#obj3">Procesar entradas de scripts</a></li>
                <li><a href="#obj4">Procesar salida de comandos</a></li>
            </ul>
        </div>

        <div class="content">

            <section id="obj1">
                <h3>Ejecutar código condicionalmente (if,test,[]...)</h3>
                <p>Los scripts de shell permiten ejecutar comandos de forma automática. El control condicional se realiza principalmente con <strong>if</strong>, <strong>test</strong> ...</p>
                <p>Todo script debe comenzar con el <code>#!</code> (shebang(/bin/bash,/bin/sh..) seguido del intérprete, usando luego comandos como <code>read</code> para guardar datos y <code>echo</code> para mostrar resultados.</p>
                <p> De apartir de esto podemos hacer scripts muy sencillos, como por ejemplo :</p>
                <img src="/images/script1.png" alt="Script basico" width="600">
                <p>Debemos recordar que siempre que editemos un archivo para crear un script habrá que darle permisos de ejecución con <code>chmod +x nombres-script</code>. </p>
                <img src="/images/script2.png" alt="resultado script basico" width="600">
                <p> Los operadores logicos más comunes :</p>
                <ul>
                    <li><strong>-e</strong> → Existe y es un archivo o directorio</li>
                    <li><strong>-f</strong> → Archivo existe y es regular</li>
                    <li><strong>-d</strong> → Directorio existe</li>
                    <li><strong>-r</strong> → Existe y tiene permisos de lectura</li>
                    <li><strong>-w</strong> → Existe y tiene permisos de escritura</li>
                    <li><strong>-x</strong> → Existe y tiene permisos de ejecución</li>
                </ul>
                <p> Para las cadenas de texto utilizamos principalmente:</p>
                <ul>
                    <li><strong>-z "$cadena"</strong> → La cadena está vacía</li>
                    <li><strong>-n "$cadena"</strong> → La cadena no está vacía</li>
                    <li><strong>"$cad1" = "$cad2"</strong> → Las cadenas son iguales</li>
                    <li><strong>"$cad1" != "$cad2"</strong> → Las cadenas son distintas</li>
                </ul>
                <p> Para los numeros utilizaremos : </p>
                <ul>
                    <li><strong>$num1 -eq $num2</strong> → Existe y es un archivo o directorio</li>
                    <li><strong>$num1 -ne $num2</strong> → Archivo existe y es regular</li>
                    <li><strong>$num1 -lt $num2</strong> → Directorio existe</li>
                    <li><strong>$num1 -gt $num2</strong> → Existe y tiene permisos de lectura</li>
                    <li><strong>$num1 -ge $num2</strong> → Existe y tiene permisos de escritura</li>
                </ul>
                <p>Estos operadores funcionan con <code>test</code> o su equivalente <code>[ ]</code>. Se utilizan junto al condicional <code>if</code>, que siempre debe cerrarse con <code>fi</code>. Por ejemplo:</p>
                <img src="/images/script3.png" alt="Script basico operadores" width="600">
                <p> En Bash, los espacios dentro de <code>[ ]</code> son obligatorios: <code>[ "$num" -eq 5 ]</code> es correcto, mientras que <code>["$num"-eq5]</code> es incorrecto.</p>
                <img src="/images/script4.png" alt="resultado ejemplos operadores" width="600">
                <p> Por ultimo, tenemos las condiciones compuestas, que mencionaré 5 básicos : </p>
                <ul>
                    <li><strong> && </strong> → Operador lógico AND. Se cumple cuando todas las condiciones individuales son verdaderas. </li>
                    <li><strong>|| </strong> → Operador lógico OR. Se cumple cuando al menos una de las condiciones es verdadera.</li>
                    <li><strong>! </strong> → Operador lógico NOT. Se utiliza para negar una condición, devolviendo el valor opuesto al original.</li>
                    <li><strong>==</strong> → Operador de igualdad. Comprueba si los valores de dos expresiones son idénticos.</li>
                    <li><strong>!=</strong> → Operador de desigualdad. Se cumple solo si los valores comparados son diferentes entre sí.</li>
                </ul>
                <p>En el scripting moderno se utilizan los dobles corchetes [[ ]] por ser más potentes y seguros. Evitan errores con variables vacías, soportan los operadores lógicos estándar (&&, ||) y no requieren obligatoriamente el uso de comillas. Si usas condiciones compuestas con [ ], fallará.:</p>
                <img src="/images/script5.png" alt="Script condicional compuesto" width="600">
                <img src="/images/script6.png" alt="resultado condicional compuesto" width="600">
                <p> Por otro lado, tenemos <code>case</code>, que es otra forma de ejecutar codigo condicionalemente : </p>
                <img src="/images/script7.png" alt=" sintaxis case" width="600">
                <p> Con esto, podremos crear dobles condicionales, un case dentro de un if, diferentes condiciones elif dentro de if.. Posibilidades infinitas</p>
            </section>

            
            <section id="obj2">
                <h3>Uso de bucles para procesar archivos y entradas</h3>
                <p>Los bucles automatizan tareas repetitivas. El bucle <code>for</code> recorre una lista definida de elementos (archivos, usuarios o comandos), mientras que <code>while</code> se ejecuta continuamente mientras se cumpla una condición específica.</p>
                <p>En un bucle <code>for</code>, podemos iterar sobre una lista manual, el contenido de un archivo o la salida de un comando:</p>
                <img src="/images/script8.png" alt="Ejemplo bucle for" width="600">
                <p>Ejemplo con <code>while</code> (ideal para lecturas línea a línea o contadores):</p>
                <img src="/images/script9.png" alt="Ejemplo bucle while" width="600">
                <p>Estas estructuras son esenciales en administración de sistemas para procesar logs, gestionar usuarios de forma masiva o monitorizar servicios.</p>
                
            </section>
            <section id="obj3">
                <h3>Procesar entradas de scripts</h3>
                <p>Los scripts pueden recibir argumentos desde la línea de comandos:</p>

                <ul>
                    <li><strong>$0</strong> → Nombre del script</li>
                    <li><strong>$1, $2, $3…</strong> → Argumentos individuales</li>
                    <li><strong>$#</strong> → Número total de argumentos</li>
                    <li><strong>$@</strong> → Todos los argumentos</li>
                </ul>

                <p>Ejemplo básico:</p>
                <pre><code>#!/bin/bash

echo "Primer argumento: $1"
echo "Segundo argumento: $2"
echo "Total: $#"</code></pre>

                <p>Ejemplo validando argumentos:</p>
                <pre><code>if [ $# -ne 1 ]; then
    echo "Uso: $0 archivo"
    exit 1
fi</code></pre>

                <p>Este tipo de validación es muy común en el examen RHCSA.</p>
            </section>

            <section id="obj4">
                <h3>Procesar la salida de comandos dentro de un script</h3>
                <p>La salida de comandos puede almacenarse en variables usando <strong>$(comando)</strong> o comillas invertidas.</p>

                <p>Ejemplo:</p>
                <pre><code>#!/bin/bash

USUARIOS=$(wc -l /etc/passwd | awk '{print $1}')
echo "Usuarios en el sistema: $USUARIOS"</code></pre>

                <p>Otro ejemplo comprobando servicios:</p>
                <pre><code>ESTADO=$(systemctl is-active sshd)

if [ "$ESTADO" = "active" ]; then
    echo "SSHD está activo"
else
    echo "SSHD no está activo"
fi</code></pre>

                <p>Esta técnica permite tomar decisiones basadas en el estado real del sistema, algo clave para automatización.</p>
            </section>

        </div>
    </div>
</main>

<footer>
    <div class="footer-content">
        <p>S2KTUX | Un lugar para aprender sistemas y redes</p>
        <div class="footer-links">
            <a href="https://github.com/s2ktux">GitHub</a>
            <a href="mailto:alaisysadma@gmail.com">Contacto</a>
            <a href="https://www.youtube.com/@s2ktux">YouTube</a>
        </div>
    </div>
</footer>

<a href="#" id="back-to-top">↑ Volver arriba</a>
<script src="/conf/scripts.js"></script>

</body>
</html>
